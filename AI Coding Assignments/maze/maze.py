__author__ = "[Jordyn Jaffe]"
__email__ = "[jtj2127@columbia.edu]"

#======================================================================#
#*#*#*# Optional: Import any allowed libraries you may need here #*#*#*#
#======================================================================#
import queue
import resource
import time

# Additional allowed libraries from Ed post
import collections
from collections import deque
import copy
import heapq
from typing import final

import psutil

#=================================#
#*#*#*# Your code ends here #*#*#*#
#=================================#

import argparse

if __name__ == "__main__":
	parser = argparse.ArgumentParser(description='Robot Path Planning | HW 1 | COMS 4701')
	parser.add_argument('-bfs', action="store_true", default=False , help="Run BFS on the map")
	parser.add_argument('-dfs', action="store_true", default=False, help= "Run DFS on the map")
	parser.add_argument('-astar', action="store_true", default=False, help="Run A* on the map")
	parser.add_argument('-ida', action="store_true", default=False, help="Run Iterative Deepening A* on the map")
	parser.add_argument('-all', action="store_true", default=False, help="Run all the 4 algorithms")
	parser.add_argument('-m', action="store", help="Map filename")

	results = parser.parse_args()

	if results.m=="" or not(results.all or results.astar or results.bfs or results.dfs or results.ida):
		print("Check the parameters : >> python hw1_UNI.py -h")
		exit()

	if results.all:
		results.bfs = results.dfs = results.astar = results.ida = True

	# Reading of map given and all other initializations
	try:
		with open(results.m) as f:
			arena = f.read()
			arena = arena.split("\n")
	except:
		print("Error in reading the arena file.")
		exit()

	# Internal representation
	print(arena)

	print("The arena of size "+ str(len(arena)) + "x" + str(len(arena[0])))
	print("\n".join(arena))

class MazeState:
	'''
	This class is an abstraction to store a maze state, which contains the following:
	- Maze configuration (arena)
	- Current Position (position in the the maze that the current state represents)
	- Parent (the state from which the current state came from)
	- Action (the action taken in the parent state, direction moved, which lead to the creation of the current state)
	- Cost (Cost of the path taken from the start to the current state)
	- Children (a child of the current state is generated by moving in a direction)
	'''
	
	def get_start_index(self):
		'''
		Returns the start index of the maze based on the given arena
		returns (-1, -1) if no start index found
		'''
		#=======================================================================#
		#*#*#*# TODO: Write your code to find the start index of the maze #*#*#*#
		#=======================================================================#

		#DONE

		#need to look for "s" in input
		#input is an array of strings; use self.arena
		#we can enumerate to get coordinates
		for y_coordinate, row in enumerate(self.arena):
			for x_coordinate, column in enumerate(row):
				if column == 's':
					return (x_coordinate, y_coordinate)

		return (-1,-1)
		#=================================#
		#*#*#*# Your code ends here #*#*#*#
		#=================================#

	def get_goal_index(self):
		'''
		Returns the goal index of the maze based on the given arena
		returns (-1, -1) if no goal index found
		'''
		#======================================================================#
		#*#*#*# TODO: Write your code to find the goal index of the maze #*#*#*#
		#======================================================================#

		#DONE

		#same as above, now just looking for g

		for y_coordinate, row in enumerate(self.arena):
			for x_coordinate, column in enumerate(row):
				if column == 'g':
					return (x_coordinate, y_coordinate)

		return (-1, -1)
		#=================================#
		#*#*#*# Your code ends here #*#*#*#
		#=================================#

	def __init__(self, arena, parent=None, action='Start', cost=0, current_position=(-1,-1)):

		self.arena = arena
		self.parent = parent
		self.action = action
		self.cost = cost
		self.children = []

		self.start = self.get_start_index()
		self.goal = self.get_goal_index()

		if(current_position[0] == -1):
			self.current_position = self.start
		else:
			self.current_position = current_position

	def display(self):
		print("\n".join(self.arena))

	def move_up(self):
		'''
		This function checks if up is a valid move from the given state.
		If up is a valid move, returns a child in which the player has moved up
		Else returns None.
		'''
		
		#=================================================================#
		#*#*#*# TODO: Write your code to move up in the puzzle here #*#*#*#
		#=================================================================#

		#get current position

		#check if moving up is valid = no "o" in box/ if row above is blank
		#need to leave star behind
		#create new child instance of arena
		#moving up = change in y by 1
		#moving up = change in the ROW!!

		current_row = self.current_position[1]
		current_col = self.current_position[0]

		if current_row > 0 and self.arena[current_row-1][current_col] != 'o':
			#need to make copy of rach row using list(row) so as not to change parent node
			new_arena = [list(row) for row in self.arena]
			#mark new arena current position with * before we move current position
			if self.current_position != self.start:
				new_arena[current_row][current_col] = '*'
			#new_arena[current_row][current_col] = '*'
			#create new instance of mazestate to create child
			#first move player up
			move_up_position = (current_col, current_row-1)

			new_child = MazeState(new_arena, parent=self, action='Move Up',  cost=self.cost + 1, current_position=move_up_position)
			return new_child
		
		return None
		#=================================#
		#*#*#*# Your code ends here #*#*#*#
		#=================================#


	def move_down(self):
		'''
		This function checks if down is a valid move from the given state.
		If down is a valid move, returns a child in which the player has moved down.
		Else returns None.
		'''
		
		#===================================================================#
		#*#*#*# TODO: Write your code to move down in the puzzle here #*#*#*#
		#===================================================================#
		#repeat move up function but instead +1 to row instead of -1

		current_row = self.current_position[1]
		current_col = self.current_position[0]

		#moving down so we need to check the bottom bounds of the maze, signified by the number of rows - 1 (bc of indexing at 0)
		#check that we are not already at the bottommost row --> use less than sign
		if current_row < len(self.arena) - 1  and self.arena[current_row + 1][current_col] != 'o':
			# need to make copy of rach row using list(row) so as not to change parent node
			new_arena = [list(row) for row in self.arena]
			# mark new arena current position with * before we move current position
			#new_arena[current_row][current_col] = '*'
			if self.current_position != self.start:
				new_arena[current_row][current_col] = '*'
			# create new instance of mazestate to create child
			# first move player up
			move_down_position = (current_col, current_row+1)

			new_child = MazeState(new_arena, parent=self, action='Move Down', cost=self.cost + 1, current_position=move_down_position)
			return new_child

		return None
		#=================================#
		#*#*#*# Your code ends here #*#*#*#
		#=================================#

	def move_left(self):
		'''
		This function checks if left is a valid move from the given state.
		If left is a valid move, returns a child in which the player has moved left.
		Else returns None.
		'''
		
		#===================================================================#
		#*#*#*# TODO: Write your code to move left in the puzzle here #*#*#*#
		#===================================================================#
		#same as move up, now changing column variable by -1
		current_row = self.current_position[1]
		current_col = self.current_position[0]

		#bounds as 0 okay bc leftmost side of maze indexed at  column 0
		if current_col > 0 and self.arena[current_row][current_col - 1] != 'o':
			# need to make copy of rach row using list(row) so as not to change parent node
			new_arena = [list(row) for row in self.arena]
			# mark new arena current position with * before we move current position
			#new_arena[current_row][current_col] = '*'
			if self.current_position != self.start:
				new_arena[current_row][current_col] = '*'
			# create new instance of mazestate to create child
			# move player left
			move_left_position = (current_col-1, current_row)

			new_child = MazeState(new_arena, parent=self, action='Move Left', cost=self.cost + 1, current_position=move_left_position)
			return new_child

		return None
		#=================================#
		#*#*#*# Your code ends here #*#*#*#
		#=================================#


	def move_right(self):
		'''
		This function checks if right is a valid move from the given state.
		If left is a valid move, returns a child in which the player has moved left.
		Else returns None.
		'''
		
		#====================================================================#
		#*#*#*# TODO: Write your code to move right in the puzzle here #*#*#*#
		#====================================================================#

		# same as move up, now changing column variable by +1
		current_row = self.current_position[1]
		current_col = self.current_position[0]

		#bounds must check we are not already at the right most column value
		#number of columns = len(self.area[0]) - 1 because indexing at 0
		if current_col < len(self.arena[0]) - 1  and self.arena[current_row][current_col + 1] != 'o':
			# need to make copy of rach row using list(row) so as not to change parent node
			new_arena = [list(row) for row in self.arena]
			# mark new arena current position with * before we move current position
			#new_arena[current_row][current_col] = '*'
			if self.current_position != self.start:
				new_arena[current_row][current_col] = '*'
			# create new instance of mazestate to create child
			#  move player right
			move_right_position = (current_col+1, current_row)

			new_child = MazeState(new_arena, parent=self, action='Move Right', cost=self.cost + 1, current_position=move_right_position)
			return new_child

		return None
		#=================================#
		#*#*#*# Your code ends here #*#*#*#
		#=================================#

	def expand(self):
		""" 
		Generate the child nodes of this node 
		"""
		
		if(len(self.children) != 0):
			return self.children

		# Do not change the order in this function, since the grading script assumes this order of expansion when checking
		children = [self.move_up(), self.move_right(), self.move_down(), self.move_left()]

		self.children = [state for state in children if state is not None]
		return self.children
		
	def __hash__(self):
		'''
		Maze states hashed based on cost. 
		This function may be modified if required.
		'''
		#============================================================================================#
		#*#*#*# Optional: May be modified if your algorithm requires a different hash function #*#*#*#
		#============================================================================================#
		
		return self.cost
		
		#=================================#
		#*#*#*# Your code ends here #*#*#*#
		#=================================#
		
	def __eq__(self, other):
		'''
		Maze states are defined as equal if they have the same dimensions and the same current position. 
		This function may be modified if required.
		'''
		
		#=============================================================================================#
		#*#*#*# Optional: May be modified if your algorithm requires a different equality check #*#*#*#
		#=============================================================================================#
		
		m1 = self.arena
		m2 = other.arena

		if(len(m1) != len(m2)):
			return False

		for i in range(0, len(m1)):
			if(not (m1[i] == m2[i])):
				return False
				
		return self.current_position == other.current_position
		
		#=================================#
		#*#*#*# Your code ends here #*#*#*#
		#=================================#
	def __lt__(self, other):
		return self.cost < other.cost

#=====================================================================================#
	#*#*#*# Optional: Write any other functions you may need in the MazeState Class #*#*#*#
	#=====================================================================================#
		
	#=================================#
	#*#*#*# Your code ends here #*#*#*#
	#=================================#



#================================================================================#
#*#*#*# Optional: You may write helper functions in this space if required #*#*#*#
#================================================================================#

#manhattan heuristic function = h(n)
def manhattan_distance(current_position, goal_position):
	return abs(current_position[0] - goal_position[0]) + abs(current_position[1] - goal_position[1])

'''
def dls(initialState, goal, max_cost):
	#following textbook pseudo code
	# Call the recursive helper function
	return recursive_dls(initialState, goal, max_cost, set())

def recursive_dls(state, goal, limit, visited):
	#check if goal is found, skipping variable initialization
	#if problem.GOAL-TEST(node.STATE) then return SOLUTION(node)
	if state.current_position == goal:
		# Found the goal
		return [state], state.cost, True, False
		#path_to_goal.append(state.arena)
		#return path_to_goal, state.cost, nodes_expanded, max_nodes_stored, max_search_depth
	#else if limit = 0 then return cutoff
	elif limit == 0:
		#cutoff
		return None, None, False, True
	#initiliaze cutoff
	visited.add(state.current_position)
	cutoff_flag = False

	#iterate children
	#for each action in problem.ACTIONS(node.STATE) do
	for child_state in state.expand():
		if child_state.current_position in visited:
			continue
		#child ← CHILD-NODE(problem, node, action)
		#result ← RECURSIVE-DLS(child, problem, limit − 1)
		result, cost, success, cutoff = recursive_dls(child_state, goal, limit - 1, visited)
		#if result = cutoff then cutoff occurred?← true
		if cutoff:
			cutoff_flag = True
		#else if result != failure (true) then return result
		elif success:
			return [state] + result, cost, True, False

	visited.remove(state.current_position)
	#if cutoff occurred? then return cutoff else return failure
	if cutoff_flag:
		#cutoff
		return None, None, False, True
	else:
		#failure
		return None, None, False, False

'''''

#=================================#
#*#*#*# Your code ends here #*#*#*#
#=================================#


'''
This function runs Breadth First Search on the input arena (which is a list of str)
Returns a ([], int, int, int, int, float, float) tuple where the [] represents the solved arena as a list of str 
and the numbers represent the other statistics to be returned
'''
def bfs(arena):

	#=================================================#
	#*#*#*# TODO: Write your BFS algorithm here #*#*#*#
	#=================================================#

	#bfs = queue, FIFO
	#explore shallowest first

	#follow pseudocode
	#make frontier queue starting with starting position
	#make new instance of MazeState to begin
	start = MazeState(arena)

	#make frontier queue

	frontier = deque([start])
	explored = set()
	#initialize other variables from script
	#path_to_goal =[]
	cost = 0
	nodes_expanded = 0
	max_nodes_stored = 0
	max_search_depth = 0
	running_time_begin = time.time()
	bfs_start_ram = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
	while frontier:
		state = frontier.popleft()
		explored.add(state.current_position)
		#nodes_expanded += 1
		current_size = len(frontier) + len(explored)
		max_nodes_stored = max(max_nodes_stored, current_size)
		#print(f"Queue Status after exploring {state.current_position}: {[s.current_position for s in frontier]}")

		#following pseduo code:
		if state.current_position == state.goal:
			#path_to_goal = [''.join(row) for row in state.arena]
			path_to_goal = []
			node = state


			#trace back path taken
			while node is not None:
				path_to_goal.append(str(node.arena))
				node = node.parent

			path_to_goal = [''.join(row) for row in state.arena]
			#calculate total runtime
			running_time = time.time() - running_time_begin

			bfs_ram = (resource.getrusage(resource.RUSAGE_SELF).ru_maxrss - bfs_start_ram) / (2 ** 10)
			#return success state

			#calculate cose
			cost = state.cost
			#path_to_goal = path_to_goal[-1]
			return path_to_goal, cost, nodes_expanded, max_nodes_stored, max_search_depth, running_time, bfs_ram

		#for neighbor in state.neighbors()
			#if neighbor not in frontier u explored:
				#frontier.enuqeue neighbor
		#visit child nodes in URDL order (deque and enqueue)

		#for move_URDL in [state.move_up(), state.move_right(), state.move_down(), state.move_left()]:
			#child_state = move_URDL

		#child_states =
		#nodes_expanded += 1
		for child_state in state.expand():
			if child_state and child_state.current_position not in explored:
				# If child state is not in explored or frontier, append it to the frontier
				if child_state.current_position not in [s.current_position for s in frontier]:
					frontier.append(child_state)
					#print(f"Added to frontier: {child_state.current_position}")
					#max_search_depth = max(max_search_depth, child_state.cost)
		#max_nodes_stored = max(max_nodes_stored, len(frontier))
		max_search_depth = max(max_search_depth, child_state.cost)
		nodes_expanded += 1
		'''''
		neighbor_added = False
		for child_state in state.expand():
			#check child is not NONE/invalid move and that not already explored before proceeding:
			if child_state and child_state.current_position not in explored and child_state.current_position not in [s.current_position for s in frontier]:
				frontier.append(child_state)
				print(f"Added to frontier: {child_state.current_position}")
				neighbor_added = True
				#generate new max values
				max_nodes_stored = max(max_nodes_stored, len(frontier))
				max_search_depth = max(max_search_depth, child_state.cost)
	#return failure
		#if neighbor_added:
			#nodes_expanded += 1
	'''
	return [], -1, -1, -1, -1, -1, -1 # Replace with return values
	#=================================#
	#*#*#*# Your code ends here #*#*#*#
	#=================================#

'''
This function runs Depth First Search on the input arena (which is a list of str)
Returns a ([], int, int, int, int, float, float) tuple where the [] represents the solved arena as a list of str 
and the numbers represent the other statistics to be returned
'''
def dfs(arena):
	start = MazeState(arena)
	#using stack structure
	frontier = [start]
	explored = set()

	#initialize variables (same as BFS)
	path_to_goal = []
	cost = 0
	nodes_expanded = 0
	max_nodes_stored = 0
	max_search_depth = 0
	running_time_begin = time.time()
	dfs_start_ram = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss

	#while not frontier is.Empty()
	while frontier:
		#state = frontier.pop()
		state = frontier.pop()
		#explored.add(state)
		explored.add(state.current_position)
		current_size = len(frontier) + len(explored)
		max_nodes_stored = max(max_nodes_stored, current_size)
		max_search_depth = max(max_search_depth, state.cost)
		#increment nodes expanded
		#nodes_expanded += 1

		#if goalTest(state):
		if state.current_position == state.goal:
			#return success(state)
			#same as BFS
			node = state

			# trace back path taken
			while node is not None:
				path_to_goal.append(node.arena)
				node = node.parent
			# reverse the path to ensure start to end order
			path_to_goal.reverse()
			path_to_goal = [''.join(row) for row in state.arena]
			# calculate total runtime
			running_time = time.time() - running_time_begin

			# RAM snippet
			dfs_ram = (resource.getrusage(resource.RUSAGE_SELF).ru_maxrss - dfs_start_ram) / (2 ** 10)

			# calculate cost
			cost = state.cost
			# return success state
			return path_to_goal, cost, nodes_expanded, max_nodes_stored, max_search_depth, running_time, dfs_ram

		#for neighbor in state.neighbors():
			#if neighbor not in frontier u explored:
				#frontier.push(neighbor)
		#push onto stack in reverse-URDL order, popping off results in URDL order
		#for move_reverse_URDL in [state.move_left(), state.move_down(), state.move_right(), state.move_up()]:
			#child_state = move_reverse_URDL
		child_state_URDL = state.expand()
		for child_state in reversed(child_state_URDL):
			if child_state and child_state.current_position not in explored:
					# If child state is not in explored or frontier, append it to the frontier
				if child_state.current_position not in [s.current_position for s in frontier]:
					frontier.append(child_state)
				# Update max search depth for the new child state
				#max_search_depth = max(max_search_depth, child_state.cost)
		#max_search_depth = max(max_search_depth, child_state.cost)
		nodes_expanded += 1

	#return on failure
	return [], -1, -1, -1, -1, -1, -1 # Replace with return values
	#=================================#
	#*#*#*# Your code ends here #*#*#*#
	#=================================#

'''
This function runs A* Search on the input arena (which is a list of str)
Returns a ([], int, int, int, int, float, float) tuple where the [] represents the solved arena as a list of str 
and the numbers represent the other statistics to be returned
'''
def astar(arena):

	#================================================#
	#*#*#*# TODO: Write your A* algorithm here #*#*#*#
	#================================================#
	start = MazeState(arena)
	goal = start.goal
	# using priority queue (heap), storing value of f(n) = g(n) + h(n) (manhattan distance + cost)
	#start by initializing list for heap queue
	frontier = []
	#push the start node onto the heap
	#need to store both the value of f(n) and the assocaiting node => use tuple
	heapq.heappush(frontier, (start.cost + manhattan_distance(start.current_position, goal), start))

	#pseduocode --> store explored as a set
	explored = set()

	# initialize variables (same as BFS)
	path_to_goal = []
	cost = 0
	nodes_expanded = 0
	max_nodes_stored = 0
	max_search_depth = 0
	running_time_begin = time.time()
	astar_start_ram = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss

	#while not frontier.isEmpty():
	while frontier:
		#state = frontier.deleteMin() = assign state the lowest value off the heap.
		#Need to assign both the f(n) value and the node for items in the tuple stored in the heap
		f_n_value, state = heapq.heappop(frontier)
		#explored.add(state)
		explored.add(state.current_position)
		#update size like bfs and dfs
		current_size = len(frontier) + len(explored)
		max_nodes_stored = max(max_nodes_stored, current_size)

		#if goalTest(state): return success state
		if state.current_position == goal:
			node = state
			#copy code from bfs algorithm for success state traceback:
			while node is not None:
				path_to_goal.append(str(node.arena))
				node = node.parent
			#path_to_goal.reverse()
			path_to_goal = [''.join(row) for row in state.arena]
			# calculate total runtime
			running_time = time.time() - running_time_begin

			astar_ram = (resource.getrusage(resource.RUSAGE_SELF).ru_maxrss - astar_start_ram) / (2 ** 10)
			# return success state

			# calculate cose
			cost = state.cost
			# path_to_goal = path_to_goal[-1]
			return path_to_goal, cost, nodes_expanded, max_nodes_stored, max_search_depth, running_time, astar_ram

		#for neighbor in state.neighbors() (same as bfs)
		for child_state in state.expand():
			# need to get its f(n) value first to appropriately store in heap
			f_n = child_state.cost + manhattan_distance(child_state.current_position, goal)
			#ensure child_state position not already explored and node itself not already in frontier (second value in tuple item)
			if child_state.current_position not in explored and all(child_state.current_position != n[1].current_position for n in frontier):
				heapq.heappush(frontier, (f_n, child_state))
				#frontier.insert(neighbor)
				#push to heap
				#heapq.heappush(frontier, (f_n, child_state))

				#update max search depth (check placement!!!)
				#max_search_depth = max(max_search_depth, child_state.cost)
			#else if neighbor in frotnier: already in frontier -> need to check if there is lower value for this node
			elif any(child_state.current_position == n[1].current_position for n in frontier):
				#check the path where you are to see if shorter and can replace in heap with lower f(n) value
				#achieve this by tracking index in heap, checking if lower than what we may insert
				for index, (f_val, n) in enumerate(frontier):
					if n.current_position == child_state.current_position and f_n < f_val:
						#update lower cost
						frontier[index] = (f_n, child_state)
						#reorder heap
						heapq.heapify(frontier)
			max_search_depth = max(max_search_depth, child_state.cost)
		#update nodes expanded before looping again
		nodes_expanded += 1

	return [], -1, -1, -1, -1, -1, -1 # Replace with return values
	#=================================#
	#*#*#*# Your code ends here #*#*#*#
	#=================================#



'''
This function runs Iterative Deepening A* Search on the input arena (which is a list of str)
Returns a ([], int, int, int, int, float, float) tuple where the [] represents the solved arena as a list of str 
and the numbers represent the other statistics to be returned
'''

'''
def ida(arena):
	state = MazeState(arena)
	bound = manhattan_distance(state.current_position, state.goal)  # or another heuristic function
	path = [state]

	while True:
		t = search(path, 0, bound)
		if t == "FOUND":
			return path, 0, 0, 0, 0, 0, 0  # Return the path when found
		if t == float('inf'):
			return []  # Return an empty list if no solution is found
		bound = t


def search(path, g, bound):
	node = path[-1]  # Get the last node in the path
	f = g + manhattan_distance(node.current_position, node.goal)  # Use your heuristic function

	if f > bound:
		return f  # Return the cost if it's above the bound

	if node.current_position == node.goal:
		return "FOUND"  # Return FOUND if the goal is reached

	min_threshold = float('inf')

	for succ in node.expand():  # Get successors of the current node
		if succ not in path:  # Avoid cycles
			path.append(succ)  # Add the successor to the path
			t = search(path, g + 1, bound)  # Recursive call with updated path
			print("Current Arena after move:")
			for row in succ.arena:
				print(''.join(row))
			print()

			if t == "FOUND":
				return "FOUND"  # Return FOUND if goal is found
			if t < min_threshold:
				min_threshold = t  # Update the minimum threshold

			path.pop()  # Remove the successor from the path after exploring

	return min_threshold  # Return the minimum threshold found
'''


def ida(arena):
	ida_arena = [row[:] for row in arena]
	state = MazeState(ida_arena)
	goal = state.goal
	bound = manhattan_distance(state.current_position, goal)

	path = [state]
	nodes_expanded = 0
	max_nodes_stored = 1
	max_search_depth = 0
	running_time_begin = time.time()
	astar_start_ram = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss

	while True:
		current_visited = set()  # Initialize a new visited set for each iteration
		result = search(path, state.cost, bound, nodes_expanded, max_search_depth, current_visited, None)

		t, node, nodes_expanded, max_search_depth = result
		# print(node.arena)

		if t == "FOUND" and node is not None:
			#print("Test")
			#print(node.type())
			#print(node)
			running_time = time.time() - running_time_begin
			astar_ram = (resource.getrusage(resource.RUSAGE_SELF).ru_maxrss - astar_start_ram) / (
						2 ** 10)

			# Convert the path to a string representation of the maze layout
			path_to_goal = []
			while node is not None:
				path_to_goal.append(node.arena)
				node = node.parent
			path_to_goal.reverse()
			if path_to_goal:
				final_arena = path_to_goal[-1]
				path_to_goal = [''.join(row) for row in final_arena]
			#final_path = path_to_goal[-1]

			#final_path_str = '\n'.join(final_path)
			#path_to_goal = [''.join(row) for row in path_to_goal[-1]]
			cost = sum(row.count('*') for row in path_to_goal) + 1
			return path_to_goal, cost, nodes_expanded, max_nodes_stored, max_search_depth, running_time, astar_ram

		if t == float('inf'):
			running_time = time.time() - running_time_begin
			astar_ram = (resource.getrusage(resource.RUSAGE_SELF).ru_maxrss - astar_start_ram) / (
						2 ** 10)

			return [], 0, nodes_expanded, max_nodes_stored, max_search_depth, running_time, astar_ram

		bound = t
def search(path, g, bound, nodes_expanded, max_search_depth, visited, final_arena):
	node = path[-1]

	# Check if the node has been visited
	if node in visited:
		return float('inf'), [], nodes_expanded, max_search_depth

	visited.add(node)  # Mark node as visited

	f = node.cost + manhattan_distance(node.current_position, node.goal)


	#if f > bound:
	#	return f, [], nodes_expanded, max_search_depth
	if isinstance(bound, (int, float)) and f > bound:  # Make sure we only compare numeric values
		return f, final_arena, nodes_expanded, max_search_depth

	if node.current_position == node.goal:
		#print("hit check if node position")
		#print(node.arena)
		#final_return_type_arena = (node.arena).copy()
		final_arena = [row[:] for row in node.arena]
		#print(final_arena)

		return "FOUND", node, nodes_expanded, max_search_depth

	min_threshold = float('inf')

	for child in node.expand():
		if child not in visited:
			nodes_expanded += 1
			max_search_depth = max(max_search_depth, g + 1)
			path.append(child)

			#print("Current Arena after move:")
			#for row in child.arena:
			#	print(''.join(row))
			#print()

			t, _, nodes_expanded, max_search_depth = search(path, child.cost + 1, bound, nodes_expanded,
														   max_search_depth, visited, final_arena)
			#return search(path, child.cost + 1, bound, nodes_expanded,
													#	   max_search_depth, visited)

			if t == "FOUND":
				#print("!!!!!!!!!")
				return "FOUND", final_arena, nodes_expanded, max_search_depth
				#break
				#continue

			if isinstance(t, (int, float)) and t < min_threshold:
				min_threshold = t

			path.pop()
		# Remove child from path after exploring

	return min_threshold, [], nodes_expanded, max_search_depth

#=================================#
	#*#*#*# Your code ends here #*#*#*#
	#=================================#

if __name__ == "__main__":
	if results.bfs:
		print("\nBFS algorithm called")
		bfs_arena, bfs_cost, bfs_nodes_expanded, bfs_max_nodes_stored, bfs_max_search_depth, bfs_time, bfs_ram = bfs(arena)
		print("\n".join(bfs_arena))
		print("BFS:")
		print("Cost: " + str(bfs_cost))
		print("Nodes Expanded: " + str(bfs_nodes_expanded))
		print("Max Nodes Stored: " + str(bfs_max_nodes_stored))
		print("Max Search Depth: " + str(bfs_max_search_depth))
		print("Time: " + str(bfs_time) + "s")
		print("RAM Usage: " + str(bfs_ram) + "kB\n")

	if results.dfs:
		print("\nDFS algorithm called")
		dfs_arena, dfs_cost, dfs_nodes_expanded, dfs_max_nodes_stored, dfs_max_search_depth, dfs_time, dfs_ram = dfs(arena)
		print("\n".join(dfs_arena))
		print("DFS:")
		print("Cost: " + str(dfs_cost))
		print("Nodes Expanded: " + str(dfs_nodes_expanded))
		print("Max Nodes Stored: " + str(dfs_max_nodes_stored))
		print("Max Search Depth: " + str(dfs_max_search_depth))
		print("Time: " + str(dfs_time) + "s")
		print("RAM Usage: " + str(dfs_ram) + "kB\n")

	if results.astar:
		print("\nA* algorithm called")
		astar_arena, astar_cost, astar_nodes_expanded, astar_max_nodes_stored, astar_max_search_depth, astar_time, astar_ram = astar(arena)
		print("\n".join(astar_arena))
		print("A*:")
		print("Cost: " + str(astar_cost))
		print("Nodes Expanded: " + str(astar_nodes_expanded))
		print("Max Nodes Stored: " + str(astar_max_nodes_stored))
		print("Max Search Depth: " + str(astar_max_search_depth))
		print("Time: " + str(astar_time) + "s")
		print("RAM Usage: " + str(astar_ram) + "kB\n")
	
	if results.ida:
		print("\nIterative Deepening A* algorithm called")
		ida_arena, ida_cost, ida_nodes_expanded, ida_max_nodes_stored, ida_max_search_depth, ida_time, ida_ram = ida(arena)
		print("\n".join(ida_arena))
		print("Iterative Deepening A*:")
		print("Cost: " + str(ida_cost))
		print("Nodes Expanded: " + str(ida_nodes_expanded))
		print("Max Nodes Stored: " + str(ida_max_nodes_stored))
		print("Max Search Depth: " + str(ida_max_search_depth))
		print("Time: " + str(ida_time) + "s")
		print("RAM Usage: " + str(ida_ram) + "kB\n")

